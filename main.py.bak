import google.generativeai as genai
import os
import sys
import textwrap
import shutil # For file operations like copying

# --- Configuration ---
# Hardcoded API key as requested.
# WARNING: Hardcoding API keys is NOT recommended for production environments.
# Use environment variables or a secure configuration management system.
GEMINI_API_KEY = r"AIzaSyDVW4vPFJ7frbYhklDgKoaE9-3CEka5Hpg"

# if not GEMINI_API_KEY or GEMINI_API_KEY == r"AIzaSyDVW4vPFJ7frbYhklDgKoaE9-3CEka5Hpg":
#     print("ERROR: GEMINI_API_KEY is not set or is a placeholder. Please provide a valid API key.")
#     sys.exit(1)

# Configure the API with your key
genai.configure(api_key=GEMINI_API_KEY)

# Initialize the Gemini model
# Using 'gemini-1.5-flash' for efficiency and general availability.
try:
    model = genai.GenerativeModel(model_name="gemini-1.5-flash")
    print("✅ Initialized Gemini 1.5 Flash model.")
except Exception as e:
    print(f"ERROR: Could not initialize 'gemini-1.5-flash' model. Attempting 'gemini-pro'. Error: {e}")
    try:
        model = genai.GenerativeModel(model_name="gemini-pro")
        print("✅ Initialized Gemini Pro model as fallback.")
    except Exception as e_fallback:
        print(f"CRITICAL ERROR: Could not initialize any Gemini model. Check your API key and model access. Error: {e_fallback}")
        sys.exit(1)

# --- File Context Configuration ---
# FOLDER YOU WANT TO GIVE ACCESS TO
# Make sure this folder exists and contains files you want to process.
FOLDER_PATH = "../Fact_Checker" # Updated folder name as requested

# File extensions to include (you can add more like '.js', '.html', '.css', '.json', etc.)
ALLOWED_EXTENSIONS = ('.py', '.md', '.txt', '.js', '.html', '.css', '.json')

# --- Agent Prompt Template ---
# This template is crucial. It instructs Gemini to return the ENTIRE modified file content
# within a markdown code block, which is then extracted and written back to the file.
AGENT_PROMPT_TEMPLATE = textwrap.dedent("""
    You are an expert code editor and reviewer.
    Your task is to analyze the provided file content, identify potential bugs,
    suggest refactorings for clarity or efficiency, and improve code quality.
    **You MUST return the ENTIRE, MODIFIED FILE CONTENT.**
    If no changes are needed, return the original file content as is.
    **Your response MUST be a single markdown code block** (e.g., ```python\n...code...\n```)
    containing the complete file content, with no additional text outside the code block.

    ---
    File Path: {filepath}
    File Content:
    ```
    {file_extension_hint}
    {file_content}
    ```
    ---
    Your Review/Suggestions (return the full modified file here):
""")

# --- Helper Function to Extract Code Block from Gemini's Response ---
def extract_code_block(response_text: str, filepath: str) -> str | None:
    """
    Extracts code content from a markdown code block in Gemini's response.
    Assumes the response is a single code block.
    """
    lines = response_text.strip().split('\n')
    
    # Determine the expected language hint from file extension
    _, ext = os.path.splitext(filepath)
    lang_hint_map = {
        '.py': 'python', '.js': 'javascript', '.html': 'html',
        '.css': 'css', '.json': 'json', '.md': 'markdown', '.txt': 'text'
    }
    expected_lang_hint = lang_hint_map.get(ext.lower(), '')

    if not lines:
        return None

    # Check for start of code block
    if lines[0].strip().startswith('```'):
        # Check if a language hint is provided, e.g., ```python
        if len(lines[0].strip()) > 3:
            actual_lang_hint = lines[0].strip()[3:].strip()
            if expected_lang_hint and actual_lang_hint.lower() != expected_lang_hint:
                print(f"WARNING: Code block language hint '{actual_lang_hint}' does not match expected '{expected_lang_hint}' for {filepath}.")
        
        # Check for end of code block
        if len(lines) > 1 and lines[-1].strip() == '```':
            # Extract content between ``` and ```
            return '\n'.join(lines[1:-1])
        else:
            print(f"WARNING: Code block for {filepath} started but not properly closed. Returning full response.")
            return response_text # Fallback to return full response if not properly closed
    else:
        print(f"WARNING: Response for {filepath} does not start with a markdown code block. Returning full response.")
        return response_text # If no code block, return the whole text


# --- Main Logic ---
def process_files_with_gemini():
    """
    Reads files from FOLDER_PATH, sends their content to Gemini for review,
    and writes the modified content back to the files.
    """
    if not os.path.exists(FOLDER_PATH):
        print(f"ERROR: Folder '{FOLDER_PATH}' not found. Please create it and add files, or update FOLDER_PATH.")
        sys.exit(1)

    print(f"\n--- Processing files in '{FOLDER_PATH}' with Gemini ---")
    
    processed_count = 0
    for root, dirs, files in os.walk(FOLDER_PATH):
        for file_name in files:
            if file_name.endswith(ALLOWED_EXTENSIONS):
                filepath = os.path.join(root, file_name)
                print(f"\n--- Analyzing file: {filepath} ---")
                
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        file_content = f.read()
                    
                    # Get file extension hint for the prompt
                    _, ext = os.path.splitext(file_name)
                    file_extension_hint = ext[1:] if ext else '' # Remove the dot

                    # Construct the specific prompt for this file
                    prompt = AGENT_PROMPT_TEMPLATE.format(
                        filepath=filepath,
                        file_extension_hint=file_extension_hint,
                        file_content=file_content
                    )

                    # Send the prompt to Gemini
                    response = model.generate_content(prompt)

                    if response.text:
                        modified_content = extract_code_block(response.text.strip(), filepath)
                        
                        if modified_content is not None:
                            # Create a backup of the original file
                            backup_filepath = filepath + ".bak"
                            shutil.copyfile(filepath, backup_filepath)
                            print(f"✅ Created backup: {backup_filepath}")

                            # Write the modified content back to the original file
                            with open(filepath, 'w', encoding='utf-8') as f:
                                f.write(modified_content)
                            print(f"✅ File '{filepath}' updated successfully with Gemini's changes.")
                        else:
                            print(f"❌ Could not extract code block from Gemini's response for {filepath}. File not modified.")
                    else:
                        print("❌ Gemini did not return a text response for this file. File not modified.")
                    
                    processed_count += 1

                except FileNotFoundError:
                    print(f"WARNING: File not found: {filepath}")
                except UnicodeDecodeError:
                    print(f"WARNING: Could not read file '{filepath}' due to encoding error. Skipping.")
                except Exception as e:
                    print(f"ERROR: An unexpected error occurred while processing '{filepath}': {e}")
                
                print("-" * 50) # Separator for clarity

    if processed_count == 0:
        print(f"\nNo allowed files found in '{FOLDER_PATH}' to process.")
    else:
        print(f"\n--- Finished processing {processed_count} files. ---")

if __name__ == "__main__":
    # Example usage:
    # 1. Create a folder named 'akash' in the same directory as this script.
    # 2. Put some .py, .md, .txt, .js, .html, .css, or .json files inside it.
    # 3. Run: python gemini_file_context_agent.py
    
    process_files_with_gemini()

